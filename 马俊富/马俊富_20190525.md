## 一、当天总结
### 学习项目
#### 第十五章
##### 进程与程序  
  首先程序与进程是什么？程序与进程又有什么区别？  
> 程序（procedure）：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我们达成某个结果。  
> 进程（process）：进程是程序在一个数据集合上的一次执行过程，在早期的UNIX、Linux 2.4及更早的版本中，它是系统进行资源分配和调度的独立基本单位。  
> 线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率.   
简而言之,一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。

##### 进程的分类  

我们需要进一步了解的就是进程分类。可以从两个角度来分：
- 以进程的功能与服务的对象来分；
- 以应用程序的服务类型来分；  

第一个角度来看，我们可以分为用户进程与系统进程：
- 用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。
- 系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。

第二角度来看，我们可以将进程分为交互进程、批处理进程、守护进程:
- 交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。
批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。
- 守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如 httpd 进程，一直处于运行状态，等待用户的访问。还有经常用的 cron（在 centOS 系列为 crond）进程，这个进程为 crontab 的守护进程，可以周期性的执行用户设定的某些任务。  

##### 进程的衍生  

关于父进程与子进程便会提及这两个系统调用 fork() 与 exec()
> fork() 是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等

> exec() 也是系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段

子进程就是父进程通过系统调用 fork() 而产生的复制品，fork() 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，所以一模一样，只有在执行 exec() 之后才会不同，而早先的 fork() 比较消耗资源后来进化成 vfork(),效率高了不少
```
pid_t p;

p = fork();
if (p == (pid_t) -1)
        /* ERROR */
else if (p == 0)
        /* CHILD */
else
        /* PARENT */
```  

##### 工作管理

我们都知道当一个进程在前台运作时我们可以用 ctrl + c 来终止它，但是若是在后台的话就不行了。

我们可以通过 & 这个符号，让我们的命令在后台中运行
```
ls &
```  
我们还可以通过 ctrl + z 使我们的当前工作停止并丢到后台中去  
被停止并放置在后台的工作我们可以使用这个命令来查看
```
jobs
```  
我们可以通过这样的一个命令将后台的工作拿到前台来  
```
#后面不加参数提取预设工作，加参数提取指定工作的编号
#ubuntu 在 zsh 中需要 %，在 bash 中不需要 %
fg [%jobnumber]
```  
之前我们通过 ctrl + z 使得工作停止放置在后台，若是我们想让其在后台运作我们就使用这样一个命令
```
#与fg类似，加参则指定，不加参则取预设
bg [%jobnumber]
```  
既然有方法将被放置在后台的工作提至前台或者让它从停止变成继续运行在后台，当然也有方法删除一个工作，或者重启等等
```
#kill的使用格式如下
kill -signal %jobnumber

#signal从1-64个信号值可以选择，可以这样查看
kill －l
```  
> 注意

> 若是在使用kill＋信号值然后直接加 pid，你将会对 pid 对应的进程进行操作

> 若是在使用kill+信号值然后 ％jobnumber，这时所操作的对象是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID  

#### 第十六章
##### 查看进程的运行状态
不管在测试的时候、在实际的生产环境中，还是自己的使用过程中，难免会遇到一些进程异常的情况，所以 Linux 为我们提供了一些工具来查看进程的状态信息。我们可以通过 top 实时的查看进程的状态，以及系统的一些信息（如 CPU、内存信息等），我们还可以通过 ps 来静态查看当前的进程信息，同时我们还可以使用 pstree 来查看当前活跃进程的树形结构。  
- top 工具是我们常用的一个查看工具，能实时的查看我们系统的一些关键信息的变化:
```
top
```  
> top 显示的第一排数据是，当前程序的名称、当前的系统的时间、该机器已经启动了多长时间、当前系统中用户数量、1、5、15分钟内cpu的平均负载。  
> top的第二行数据，基本上第二行是进程的一个情况统计  
> top的第三行数据，这一行基本上是 CPU 的一个使用情况的统计  
> top 的第四行数据，这一行基本上是内存的一个使用情况的统计  
> top 的第五行数据，这一行基本上是交换区的一个使用情况的统计了  
> 再下面就是进程的一个情况了  
- ps 也是我们最常用的查看进程的工具之一  
```
ps aux
```  
可以用man手册了解详细keywords含义。  
- pstree 可以很直接的看到相同的进程数量，最主要的还是我们可以看到所有进程之间的相关性。  
```
pstree
```  
```
pstree -up
#参数选择：
#-A  ：各程序树之间以 ASCII 字元來連接；
#-p  ：同时列出每个 process 的 PID；
#-u  ：同时列出每个 process 的所屬账户名称。
```  

##### 进程的结束控制
- kill 命令  
使用kill 来操作下一些不属于 job 范畴的进程，直接对 pid 下手
```
#首先我们使用图形界面打开了 gedit、gvim，用 ps 可以查看到
ps aux  
#使用9这个信号强制结束 gedit 进程
kill -9 1608  
#我们再查找这个进程的时候就找不到了
ps aux | grep gedit
```  

##### 进程的执行顺序
进程的执行顺序依靠进程的优先级值来判定进程调度的优先级，而优先级的值就是上文所提到的 PR 与 nice 来控制与体现了。  
nice 的值我们是可以通过 nice 命令来修改的，而需要注意的是 nice 值可以调整的范围是 -20 ~ 19，其中 root 有着至高无上的权力，既可以调整自己的进程也可以调整其他用户的程序，并且是所有的值都可以用，而普通用户只可以调制属于自己的进程，并且其使用的范围只能是 0 ~ 19，因为系统为了避免一般用户抢占系统资源而设置的一个限制
```
#打开一个程序放在后台，或者用图形界面打开
nice -n -5 vim &  
#用 ps 查看其优先级
ps -afxo user,ppid,pid,stat,pri,ni,time,command | grep vim
```  
我们还可以用 renice 来修改已经存在的进程的优先级  
```
renice -5 pid
```  

#### 第十七章
##### 常见的日志
在 Linux 中大部分的发行版都内置使用 syslog 系统日志，那么通过前期的课程我们了解到常见的日志一般存放在 /var/log 中，我们来看看其中有哪些日志
```
ll /var/log
```  
我们可以根据服务对象粗略的将日志分为两类  
- 系统日志
- 应用日志

系统日志主要是存放系统内置程序或系统内核之类的日志信息如 alternatives.log 、btmp 等等，应用日志主要是我们装的第三方应用所产生的日志如 tomcat7 、apache2 等等。  
接下来我们来看看常见的系统日志有哪些，他们都记录了怎样的信息  
```
日志名称	记录信息
alternatives.log	系统的一些更新替代信息记录
apport.log	应用程序崩溃信息记录
apt/history.log	使用 apt-get 安装卸载软件的信息记录
apt/term.log	使用 apt-get 时的具体操作，如 package 的下载、打开等
auth.log	登录认证的信息记录
boot.log	系统启动时的程序服务的日志信息
btmp	错误的信息记录
Consolekit/history	控制台的信息记录
dist-upgrade	dist-upgrade 这种更新方式的信息记录
dmesg	启动时，显示屏幕上内核缓冲信息,与硬件有关的信息
dpkg.log	dpkg 命令管理包的日志。
faillog	用户登录失败详细信息记录
fontconfig.log	与字体配置有关的信息记录
kern.log	内核产生的信息记录，在自己修改内核时有很大帮助
lastlog	用户的最近信息记录
wtmp	登录信息的记录。wtmp可以找出谁正在进入系统，谁使用命令显示这个文件或信息等
syslog	系统信息记录
```  

##### 配置的日志  
这些日志是如何产生的？通过上面的例子我们可以看出大部分的日志信息似乎格式都很类似，并且都出现在这个文件夹中。

这样的实现可以通过两种方式：

- 一种是由软件开发商自己来自定义日志格式然后指定输出日志位置；
- 一种方式就是 Linux 提供的日志服务程序，而我们这里系统日志是通过 syslog 来实现，提供日志管理服务。  
syslog 是一个系统日志记录程序，在早期的大部分 Linux 发行版都是内置 syslog，让其作为系统的默认日志收集工具，虽然随着时代的进步与发展，syslog 已经年老体衰跟不上时代的需求，所以他被 rsyslog 所代替了，较新的 Ubuntu、Fedora 等等都是默认使用 rsyslog 作为系统的日志收集工具

rsyslog的全称是 rocket-fast system for log，它提供了高性能，高安全功能和模块化设计。rsyslog 能够接受各种各样的来源，将其输入，输出的结果到不同的目的地。rsyslog 可以提供超过每秒一百万条消息给目标文件。

这样能实时收集日志信息的程序是有其守护进程的，如 rsyslog 的守护进程便是 rsyslogd  

既然它是一个服务，那么它便是可以配置，为我们提供一些我们自定义的服务

首先我们来看 rsyslog 的配置文件是什么样子的，而 rsyslog 的配置文件有两个，

一个是 /etc/rsyslog.conf
一个是 /etc/rsyslog.d/50-default.conf。
第一个主要是配置的环境，也就是 rsyslog 加载什么模块，文件的所属者等；而第二个主要是配置的 Filter Conditions  
```
vim /etc/rsyslog.conf

vim /etc/rsyslog.d/50-default.conf
```  

与日志相关的还有一个还有常用的命令 logger,logger 是一个 shell 命令接口，可以通过该接口使用 Syslog 的系统日志模块，还可以从命令行直接向系统日志文件写入信息。
```
#首先将syslog启动起来
sudo service rsyslog start  
#向 syslog 写入数据
ping 127.0.0.1 | logger -it logger_test -p local3.notice &  
#查看是否有数据写入
sudo tail -f /var/log/syslog  
```  

##### 转储的日志
logrotate 程序是一个日志文件管理工具。用来把旧的日志文件删除，并创建新的日志文件。我们可以根据日志文件的大小，也可以根据其天数来切割日志、管理日志，这个过程又叫做“转储”。

大多数 Linux 发行版使用 logrotate 或 newsyslog 对日志进行管理。logrotate 程序不但可以压缩日志文件，减少存储空间，还可以将日志发送到指定 E-mail，方便管理员及时查看日志。

显而易见，logrotate 是基于 CRON 来运行的，其脚本是 /etc/cron.daily/logrotate；同时我们可以在 /etc/logrotate 中找到其配置文件
```
cat /etc/logrotate.conf
```  
```
# see "man logrotate" for details  //可以查看帮助文档  
# rotate log files weekly
weekly                             //设置每周转储一次(daily、weekly、monthly当然可以使用这些参数每天、星期，月 )  
# keep 4 weeks worth of backlogs
rotate 4                           //最多转储4次  
# create new (empty) log files after rotating old ones
create                             //当转储后文件不存在时创建它  
# uncomment this if you want your log files compressed
compress                          //通过gzip压缩方式转储（nocompress可以不压缩）  
# RPM packages drop log rotation information into this directory
include /etc/logrotate.d           //其他日志文件的转储方式配置文件，包含在该目录下  
# no packages own wtmp -- we'll rotate them here
/var/log/wtmp {                    //设置/var/log/wtmp日志文件的转储参数
    monthly                        //每月转储
    create 0664 root utmp          //转储后文件不存在时创建它，文件所有者为root，所属组为utmp，对应的权限为0664
    rotate 1                       //最多转储一次
}
```  
可以用man手册查看更多信息。  

## 二、第二日计划
开始java课程学习。
#### 下附运行截图：
![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1079819-20190525-1558783442881)  

![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1079819-20190525-1558784459902)  
![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1079819-20190525-1558784428147)  
![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1079819-20190525-1558784663287)  

![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1079819-20190525-1558785275168)


### 今日学习心得  
通过今天实验初步了解了进程在系统中存在的概念，以及进程如何在系统中衍生，发展，以及进程之间存在的相互关系，可以为我们在后续学习进程管理打下基础，同时了解了工作与进程，以及工作管理的一些使用性的操作。学会了进程的查看命令 ps，pstree，top，以及使用这些命令时所得到的信息的含义，从而获取我们需要的信息，同时还学会了进程的管理命令 kill，nice，renice。了解了系统日志结构，以及我们可以从中获取什么样的信息，给我们带来什么样的价值。还有日志工具的配置，以及省心省力的 logrotate。
